---
globs: durable-execution-orpc-utils/**/*.ts
---

# oRPC Utils: Client-Server Patterns for Durable Execution

This rule covers the oRPC integration patterns for creating distributed durable execution architectures with client-server separation.

## Architecture Overview

The `durable-execution-orpc-utils` package enables a powerful architecture pattern:

```mermaid
sequenceDiagram
    participant Web as Web App (Serverless)
    participant Server as Durable Executor Server
    participant DB as Storage Backend

    Web->>Server: enqueueTask(taskId, input)
    Server->>DB: Store task execution
    Server->>Web: executionId

    Note over Server: Background processing
    Server->>Web: task.run(webAppClient.call(...))
    Web->>Server: taskResult
    Server->>DB: Update execution status

    Web->>Server: getTaskExecution(executionId)
    Server->>Web: execution(status=completed, output)
```

**Key Benefits**:

- Web app can be serverless (no long-running processes)
- Durable executor server handles state management and persistence
- Type-safe communication via oRPC procedures
- Tasks can call back to web app for business logic

## Package Structure

**Split Entry Points**:

- `durable-execution-orpc-utils/server` - Server-side router creation
- `durable-execution-orpc-utils/client` - Client-side handles and utilities

**Dependencies**:

- Peer dependencies: `@orpc/client`, `@orpc/contract`, `@orpc/server`, `durable-execution`
- Runtime dependency: `@gpahal/std` for error utilities

## Server-Side Patterns

### Creating Task Router

From [durable-execution-orpc-utils/src/server.ts](mdc:durable-execution-orpc-utils/src/server.ts):

```typescript
import { os } from '@orpc/server'
import { DurableExecutor } from 'durable-execution'
import { createTasksRouter } from 'durable-execution-orpc-utils/server'

// Define tasks
const tasks = {
  processFile: executor.task({
    id: 'processFile',
    timeoutMs: 30_000,
    run: async (ctx, input: { filePath: string }) => {
      // Task logic here
      return { processed: true }
    }
  }),
  sendEmail: executor.task({
    id: 'sendEmail',
    timeoutMs: 10_000,
    run: async (ctx, input: { to: string, subject: string }) => {
      // Email logic here
      return { sent: true }
    }
  })
}

// Create oRPC router
export const tasksRouter = createTasksRouter(os, executor, tasks)
```

**Router Procedures**:

- `enqueueTask({ taskId, input, options? })` - Enqueue task and return execution ID
- `getTaskExecution({ taskId, executionId })` - Get current execution status

### Converting Client Procedures to Tasks

```typescript
import { convertClientProcedureToTask } from 'durable-execution-orpc-utils/server'

// Create client for web app
const webAppClient: RouterClient<typeof webAppRouter> = createORPCClient(webAppLink)

// Convert client procedure to durable task
const clientEmailTask = convertClientProcedureToTask(
  executor,
  { id: 'sendEmailViaWebApp', timeoutMs: 10_000 },
  webAppClient.sendEmail
)
```

**Pattern Benefits**:

- Web app implements business logic as oRPC procedures
- Server wraps client procedures as durable tasks
- Business logic stays in web app, durability handled by server

## Client-Side Patterns

### Basic Task Router Client

From [durable-execution-orpc-utils/src/client.ts](mdc:durable-execution-orpc-utils/src/client.ts):

```typescript
import { createORPCClient } from '@orpc/client'
import { RPCLink } from '@orpc/client/fetch'
import type { RouterClient } from '@orpc/server'

// Create client for task router
const tasksRouterLink = new RPCLink({
  url: 'http://localhost:3000/rpc',
  headers: () => ({ authorization: 'Bearer TOKEN' })
})

const tasksRouterClient: RouterClient<typeof tasksRouter> = createORPCClient(tasksRouterLink)

// Enqueue task
const executionId = await tasksRouterClient.enqueueTask({
  taskId: 'processFile',
  input: { filePath: '/path/to/file' }
})

// Get execution status
const execution = await tasksRouterClient.getTaskExecution({
  taskId: 'processFile',
  executionId
})
```

### Type-Safe Task Handles

```typescript
import { createTaskClientHandles } from 'durable-execution-orpc-utils/client'

// Create type-safe handles
const handles = createTaskClientHandles(tasksRouterClient, tasks)

// Type-safe enqueue (input type inferred from task definition)
const executionId = await handles.processFile.enqueue({ filePath: '/path/to/file' })

// Type-safe execution fetch (output type inferred)
const execution = await handles.processFile.getExecution(executionId)
```

**Type Safety Benefits**:

- Input types automatically inferred from task definitions
- Output types flow through to execution results
- Compile-time validation of task IDs and inputs

## Error Handling Patterns

**Server-Side Error Mapping**:

```typescript
// From server.ts implementation
try {
  const handle = await executor.enqueueTask(task, input.input, input.options)
  return handle.getExecutionId()
} catch (error) {
  if (error instanceof DurableExecutionNotFoundError) {
    throw new ORPCError('NOT_FOUND', { message: error.message })
  }
  if (error instanceof DurableExecutionError) {
    throw new ORPCError('BAD_REQUEST', { message: error.message })
  }
  throw new ORPCError('INTERNAL_SERVER_ERROR', {
    message: getErrorMessage(error)
  })
}
```

**Client-Side Error Handling**:

```typescript
import { safe } from '@orpc/client'

// Safe error handling
const [data, error] = await safe(handles.processFile.enqueue({ filePath: '/invalid' }))

if (error) {
  if (error.code === 'NOT_FOUND') {
    console.log('Task not found')
  } else if (error.code === 'BAD_REQUEST') {
    console.log('Invalid input:', error.message)
  }
} else {
  console.log('Execution ID:', data)
}
```

## Advanced Patterns

### Hybrid Task Execution

```typescript
// Server defines both local and remote tasks
const hybridTasks = {
  // Local task (runs on server)
  processData: executor.task({
    id: 'processData',
    run: async (ctx, input) => {
      // CPU-intensive work on server
      return processedData
    }
  }),

  // Remote task (calls back to web app)
  validateBusiness: convertClientProcedureToTask(
    executor,
    { id: 'validateBusiness', timeoutMs: 5000 },
    webAppClient.validateBusinessRules
  ),

  // Parent task combining both
  completeWorkflow: executor.parentTask({
    id: 'completeWorkflow',
    runParent: async (ctx, input) => ({
      output: input,
      childrenTasks: [
        { task: hybridTasks.processData, input },
        { task: hybridTasks.validateBusiness, input }
      ]
    }),
    finalizeTask: {
      id: 'finalizeWorkflow',
      run: async (ctx, { output, childrenTaskExecutionsOutputs }) => {
        // Combine results from both local and remote tasks
        return {
          processedData: childrenTaskExecutionsOutputs[0].output,
          validation: childrenTaskExecutionsOutputs[1].output,
          original: output
        }
      }
    }
  })
}
```

### Authentication and Context

```typescript
// Server with authentication context
const authenticatedTasksRouter = os
  .context<{ userId: string }>()
  .use(async ({ input, next }) => {
    const userId = await validateToken(input.headers.authorization)
    return next({ userId })
  })
  .tag('tasks')

export const tasksRouter = createTasksRouter(authenticatedTasksRouter, executor, tasks)

// Client with automatic auth headers
const authenticatedClient = createORPCClient(new RPCLink({
  url: 'http://localhost:3000/rpc',
  headers: () => ({
    authorization: `Bearer ${getAuthToken()}`
  })
}))
```

## Testing Patterns

**Server Testing**:

```typescript
import { InMemoryStorage } from 'durable-execution'

describe('Tasks Router', () => {
  let executor: DurableExecutor
  let tasksRouter: Router

  beforeEach(() => {
    executor = new DurableExecutor(new InMemoryStorage())
    tasksRouter = createTasksRouter(os, executor, tasks)
  })

  it('should enqueue and execute task', async () => {
    const caller = tasksRouter.createCaller({})

    const executionId = await caller.enqueueTask({
      taskId: 'processFile',
      input: { filePath: '/test' }
    })

    expect(executionId).toBeDefined()

    // Wait for execution to complete
    const execution = await caller.getTaskExecution({
      taskId: 'processFile',
      executionId
    })

    expect(execution.status).toBe('completed')
  })
})
```

**Client Testing**:

```typescript
import { createMockORPCClient } from '@orpc/client/mock'

describe('Task Client', () => {
  it('should handle type-safe task enqueuing', async () => {
    const mockClient = createMockORPCClient<typeof tasksRouter>({
      enqueueTask: vi.fn().mockResolvedValue('execution-id-123'),
      getTaskExecution: vi.fn().mockResolvedValue({
        status: 'completed',
        output: { processed: true }
      })
    })

    const handles = createTaskClientHandles(mockClient, tasks)

    const executionId = await handles.processFile.enqueue({ filePath: '/test' })
    expect(executionId).toBe('execution-id-123')
  })
})
```

## Performance Considerations

**Connection Management**:

- Use connection pooling for HTTP clients
- Configure appropriate timeouts for task operations
- Implement retry logic for network failures

**Batching**:

- Consider batching multiple task enqueues when possible
- Use streaming for large result sets
- Implement pagination for execution queries

**Caching**:

- Cache task definitions on client side
- Use conditional requests for execution status
- Implement client-side result caching where appropriate

This pattern enables powerful distributed architectures where business logic can remain in lightweight, serverless applications while durability and state management is handled by dedicated executor servers.
