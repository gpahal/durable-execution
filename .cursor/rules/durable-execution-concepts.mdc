---
description: Core concepts and patterns for durable execution domain
---

# Durable Execution Domain Concepts

## Core Architecture

### Task System

Tasks are created using the DurableExecutor's fluent API:

- **Task Creation**: Use `executor.task()`, `executor.parentTask()`, or `executor.sequentialTasks()`
- **Input Validation**: Use `executor.inputSchema()` or `executor.validateInput()` for validation
- **Task Execution**: Stateful execution tracking with comprehensive status management
- **Task Hierarchy**: Parent-child relationships with finalization tasks

### Execution States

Task executions follow this lifecycle (see `TaskExecutionStatus`):

- `ready` → `running` → `completed` | `failed` | `timed_out` | `cancelled`
- `waiting_for_children` → `waiting_for_finalize` → final state
- `finalize_failed` for finalization task failures

### Storage Layer

Implemented via `storage.ts` interface:

- `TaskExecutionsStorage` - Core persistence interface
- `TaskExecutionStorageValue` - Serializable execution state
- Atomic operations for state transitions
- Mutex support for concurrent access

### Executor Engine

The `DurableExecutor` (`src/executor.ts`) orchestrates:

```ts
import { DurableExecutor } from 'durable-execution'

const executor = new DurableExecutor(storage)

// Start durable executor
executor.start()

// Enqueue tasks
const handle = await executor.enqueueTask(myTask, input)
const result = await handle.waitAndGetFinishedExecution()

// Graceful shutdown
await executor.shutdown()
```

- Task enqueueing and execution
- Retry logic with exponential backoff
- Timeout and cancellation handling
- Parent-child task coordination
- Graceful shutdown and cleanup

## Key Patterns

### Task Definition Pattern

```ts
const emailTask = executor
  .inputSchema(Schema.standardSchemaV1(Schema.Struct({ to: Schema.String, subject: Schema.String })))
  .task({
    id: 'sendEmail',
    retryOptions: {
      maxAttempts: 3,
      baseDelayMs: 1000,
      delayMultiplier: 1.5,
      maxDelayMs: 30000,
    },
    timeoutMs: 30000,
    run: async (ctx, input) => {
      // Send email logic
      return { messageId: 'msg_123' }
    },
  })
```

### Sequential Task Pattern

Use `sequentialTasks` method for ordered execution:

```ts
const taskA = executor.task({
  id: 'a',
  timeoutMs: 1000,
  run: (ctx, input: { name: string }) => ({
    name: input.name,
    taskAOutput: `Hello from task A, ${input.name}!`,
  }),
})

const taskB = executor.task({
  id: 'b',
  timeoutMs: 1000,
  run: (ctx, input: { name: string; taskAOutput: string }) => ({
    taskAOutput: input.taskAOutput,
    taskBOutput: `Hello from task B, ${input.name}!`,
  }),
})

const sequentialTask = executor.sequentialTasks('seq', [taskA, taskB])
```

### Parent Task Pattern

For workflows with child tasks and finalization:

```ts
const parentTask = executor.parentTask({
  id: 'workflow',
  timeoutMs: 60000,
  runParent: (ctx, input: { name: string }) => ({
    output: `Parent output for ${input.name}`,
    children: [
      childTask(childTaskA, { name: input.name }),
      childTask(childTaskB, { name: input.name }),
    ],
  }),
  finalize: {
    id: 'workflowFinalize',
    timeoutMs: 30000,
    run: (ctx, { output, children }) => {
      // Combine parent and children outputs
      return {
        parentOutput: output,
        childrenResults: children.map(child => child.output)
      }
    },
  },
})
```

### Sleeping Task Pattern

Sleeping tasks wait for an external signal (webhook, event) and complete when explicitly woken up. They are identified by a unique input string.

```ts
// Define a sleeping task that times out if not woken up
const waitForWebhook = executor.sleepingTask<{ webhookId: string }>({
  id: 'waitForWebhook',
  timeoutMs: 24 * 60 * 60 * 1000,
})

// Enqueue with a unique id (e.g., correlation id)
const handle = await executor.enqueueTask(waitForWebhook, 'uniqueId')

// Later, e.g., in a webhook handler
await executor.wakeupSleepingTaskExecution(waitForWebhook, 'uniqueId', {
  status: 'completed',
  output: { webhookId: '123' },
})
```

### Polling Task Pattern

Create a polling task that repeatedly runs a small check task until it reports done.

```ts
// Poll body returns either { isDone: true, output } or { isDone: false }
const pollTask = executor.task<{},{ isDone: boolean; output?: number }>({
  id: 'poll',
  sleepMsBeforeRun: 100,
  timeoutMs: 1000,
  run: () => ({ isDone: Math.random() > 0.8, output: 42 }),
})

// maxAttempts=20, sleepMs=100ms between attempts
const pollingTask = executor.pollingTask('polling', pollTask, 20, 100)

const pollingHandle = await executor.enqueueTask(pollingTask)
const pollingFinished = await pollingHandle.waitAndGetFinishedExecution()
```

## Implementation Guidelines

### Error Handling

- Use `DurableExecutionError` hierarchy for domain-specific errors
- Create retryable vs non-retryable errors using static methods
- Include serializable error context for debugging

```ts
import { DurableExecutionError } from 'durable-execution'

// Non-retryable error
throw DurableExecutionError.nonRetryable('Invalid input data')

// Retryable error
throw DurableExecutionError.retryable('Network timeout, please retry')

// Check error in finalize function
if (child.status !== 'completed') {
  throw DurableExecutionError.nonRetryable('Child task failed')
}
```

### Serialization

- Use `createSuperjsonSerializer()` for complex object serialization
- Ensure all task inputs/outputs are serializable
- Store execution state as JSON-compatible structures

```ts
import { createSuperjsonSerializer } from 'durable-execution'

const serializer = createSuperjsonSerializer()
const executor = new DurableExecutor(storage, { serializer })
```

### Concurrency

- Tasks execute concurrently by default within the executor
- Use storage mutex for atomic state updates
- Implement proper cancellation signal handling

### Testing

- Use `durable-execution-storage-test-utils` for storage validation
- Test with realistic concurrency scenarios (250+ tasks)
- Verify parent-child task relationships and finalization
- Test retry mechanisms and timeout handling

## Storage Implementations

### In-Memory Storage

Default implementation in `in-memory-storage.ts`:

```ts
import { InMemoryTaskExecutionsStorage } from 'durable-execution'

const storage = new InMemoryTaskExecutionsStorage()
const executor = new DurableExecutor(storage)
```

- Suitable for development and testing
- No persistence across process restarts
- Built-in mutex support

### Database Storage

**Production Storage Options**:

- **durable-execution-storage-drizzle**: PostgreSQL, MySQL, SQLite support with optimized indexes and transactions

## Integration Points

### Monitoring and Logging

- Implement custom `Logger` interface for structured logging
- Monitor task execution metrics and failure rates
- Track execution duration and resource usage
- Set up alerts for high failure rates or timeouts
