---
globs: *.ts,*.tsx,*.mts,*.cts
---

# TypeScript Coding Standards

## Configuration

- Use strict TypeScript configuration from `@gpahal/tsconfig/base.json`
- ESM modules only - all files use `"type": "module"`
- Target Node.js >=20.0.0

## Code Style

- Use ESLint with `@gpahal/eslint-config/base`
- Prettier formatting with `@gpahal/prettier-config`
- Import sorting with `@ianvs/prettier-plugin-sort-imports`

## Type Definitions

- Export types explicitly using `export type` syntax
- Use generic types for reusable components
- Leverage TypeScript utility types for type inference

### Example Type Patterns

```ts
// Task creation using executor fluent API
const myTask = executor
  .inputSchema(z.object({ name: z.string() }))
  .task({
    id: 'myTask',
    timeoutMs: 30000,
    run: (ctx, input) => {
      return { result: `Hello ${input.name}` }
    },
  })

// Type inference utilities (exported from core)
export type InferTaskInput<T> = T extends Task<infer TInput, any> ? TInput : never
export type InferTaskOutput<T> = T extends Task<any, infer TOutput> ? TOutput : never
```

## Schema Validation

- Use Zod for runtime validation with TypeScript integration
- Follow Standard Schema spec with `@standard-schema/spec`
- Export both TypeScript types and Zod schemas

### Schema Pattern

```ts
import z from 'zod'

// Input validation using inputSchema
const validatedTask = executor
  .inputSchema(z.object({
    email: z.string().email(),
    retryCount: z.number().int().min(0).max(5),
  }))
  .task({
    id: 'processEmail',
    timeoutMs: 30000,
    run: (ctx, input) => {
      // input is automatically typed and validated
      return { processed: true, email: input.email }
    },
  })

// Manual validation using validateInput
const manualValidatedTask = executor
  .validateInput((input: { name: string }) => {
    if (!input.name.trim()) {
      throw new Error('Name cannot be empty')
    }
    return input
  })
  .task({
    id: 'processName',
    timeoutMs: 30000,
    run: (ctx, input) => ({ greeting: `Hello ${input.name}` }),
  })
```

## Error Handling

- Create custom error classes extending base Error
- Include serializable error information for storage
- Use consistent error types across the system

### Error Pattern

```ts
import { DurableExecutionError } from 'durable-execution'

// In task run functions
const myTask = executor.task({
  id: 'myTask',
  timeoutMs: 30000,
  run: (ctx, input) => {
    if (input.invalid) {
      // Non-retryable error for invalid input
      throw DurableExecutionError.nonRetryable('Invalid input provided')
    }

    if (networkUnavailable) {
      // Retryable error for transient issues
      throw DurableExecutionError.retryable('Network temporarily unavailable')
    }

    return { success: true }
  },
})
```

## Import Organization

1. Standard library imports
2. Third-party library imports
3. Internal package imports (relative paths)
4. Type-only imports using `import type`

## Documentation

- Use TSDoc comments for public APIs
- Include `@example` blocks for complex functions
- Reference related documentation with links
