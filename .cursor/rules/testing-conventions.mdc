---
globs: *.test.ts,*.test.tsx,tests/**
---

# Testing Conventions

## Test Framework Setup

- Use Vitest for all testing with 120-second timeouts for storage tests
- Configuration in [vitest.config.ts](mdc:durable-execution/vitest.config.ts)
- Coverage reporting with `@vitest/coverage-v8`
- Global test setup for common utilities

## Test File Organization

```text
tests/
├── examples.test.ts       # Example usage patterns and documentation
├── executor.test.ts       # Core executor functionality tests
├── storage.test.ts        # Storage interface tests
├── parent-task.test.ts    # Parent-child task orchestration
├── concurrent-scenarios.test.ts  # Race conditions and high concurrency
└── *.test.ts             # Other test files organized by feature
```

## Testing Patterns

### Storage Implementation Testing

Use [durable-execution-storage-test-utils](mdc:durable-execution-storage-test-utils/) for comprehensive storage validation:

```ts
import { runStorageTest } from 'durable-execution-storage-test-utils'

describe('MyStorage', () => {
  it('should pass comprehensive storage tests', async () => {
    const storage = createMyStorage()
    await runStorageTest(storage, async () => {
      // Cleanup logic
    })
  })
})
```

### Executor Testing

Test executor functionality with realistic scenarios:

- Concurrent task execution (250+ tasks)
- Parent-child task hierarchies
- Retry mechanisms and error handling
- Timeout and cancellation scenarios
- Graceful shutdown behavior

### Sleeping and Polling Tasks

```ts
// Sleeping task: wakeup flow
const sleeping = executor.sleepingTask<string>({ id: 'sleep', timeoutMs: 5_000 })
const handle = await executor.enqueueTask(sleeping, 'unique')
await executor.wakeupSleepingTaskExecution(sleeping, 'unique', { status: 'completed', output: 'ok' })
const done = await handle.waitAndGetFinishedExecution()
expect(done.status).toBe('completed')

// Polling task: completes when inner poll returns isDone
const pollBody = executor.task({ id: 'pollBody', timeoutMs: 1000, run: () => ({ isDone: true, output: 1 }) })
const polling = executor.pollingTask('polling', pollBody, 3, 50) // 3 attempts, 50ms between attempts
const pollingResult = await (await executor.enqueueTask(polling)).waitAndGetFinishedExecution()
expect(pollingResult.status).toBe('completed')
```

### Database Testing

For storage implementations with real databases:

- **Drizzle**: Use Testcontainers (PostgreSQL and MySQL), in-memory SQLite
- Clean up database state between tests

### Example Test Structure

```ts
describe('TaskExecution', () => {
  let executor: DurableExecutor
  let storage: TaskExecutionsStorage

  beforeEach(async () => {
    storage = new InMemoryTaskExecutionsStorage()
    executor = new DurableExecutor(storage)
    executor.startBackgroundProcesses()
  })

  afterEach(async () => {
    await executor.shutdown()
    await storage.deleteAll()
  })

  it('should handle task retry on failure', async () => {
    // Test implementation
  })
})
```

## Test Data Management

### Temporary Resources

Use utility functions for temporary file/directory management:

```ts
import { withTemporaryDirectory, withTemporaryFile } from 'durable-execution-storage-test-utils'

it('should work with temporary files', () => {
  return withTemporaryFile(async (filePath) => {
    // Test with temporary file
  })
})
```

### Task Factory Patterns

Create reusable task definitions for testing:

```ts
const createTestTask = <TInput, TOutput>(id: string, overrides?: Partial<Task<TInput, TOutput>>) => ({
  id,
  retryOptions: { maxAttempts: 1, baseDelayMs: 0, maxDelayMs: 0, delayMultiplier: 1 },
  timeoutMs: 1000,
  ...overrides
})
```

## Test Coverage Requirements

- Aim for >90% code coverage on core functionality
- Test error paths and edge cases thoroughly
- Include integration tests for cross-package functionality
- Validate serialization/deserialization of complex objects

## Performance Testing

- Test with realistic concurrency levels
- Measure execution time for bulk operations
- Validate memory usage doesn't grow unbounded
- Test timeout behavior under load

## Mocking Strategies

- Mock external dependencies (databases, network calls)
- Use dependency injection for testability
- Preserve type safety when mocking
- Test both success and failure scenarios

## Assertion Patterns

```ts
// Task execution assertions
expect(execution.status).toBe('completed')
expect(execution.output).toEqual(expectedOutput)
expect(execution.error).toBeUndefined()

// Storage assertions
const storedExecutions = await storage.getManyById([{ executionId: execution.executionId }])
const storedExecution = storedExecutions[0]
expect(storedExecution).toBeDefined()
expect(storedExecution).toMatchObject(expectedStorageValue)
```

## Test Documentation

- Include descriptive test names that explain the scenario
- Add comments for complex test setup or assertions
- Use `it.skip` or `it.todo` for incomplete tests
- Group related tests with `describe` blocks
