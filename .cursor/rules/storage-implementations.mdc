---
globs: durable-execution-storage-*/**/*.ts,durable-execution/src/storage.ts,durable-execution/src/in-memory-storage.ts
---

# Storage Implementation Patterns

This rule covers the Storage interface and implementation patterns for durable execution storage backends.

## Core Storage Interface

The Storage interface from [durable-execution/src/storage.ts](mdc:durable-execution/src/storage.ts) defines the contract that all storage implementations must follow:

```typescript
export type Storage = StorageTx & {
  withTransaction: <T>(fn: (tx: StorageTx) => Promise<T>) => Promise<T>
}

export type StorageTx = {
  insertTaskExecutions: (executions: Array<TaskExecutionStorageValue>) => void | Promise<void>
  getTaskExecutions: (where: TaskExecutionStorageWhere, limit?: number) => Array<TaskExecutionStorageValue> | Promise<Array<TaskExecutionStorageValue>>
  updateTaskExecutionsAndReturn: (where: TaskExecutionStorageWhere, update: TaskExecutionStorageUpdate, limit?: number) => Array<TaskExecutionStorageValue> | Promise<Array<TaskExecutionStorageValue>>
  updateAllTaskExecutions: (where: TaskExecutionStorageWhere, update: TaskExecutionStorageUpdate) => number | Promise<number>
  insertFinishedChildTaskExecutionIfNotExists: (finishedChildTaskExecution: FinishedChildTaskExecutionStorageValue) => void | Promise<void>
  deleteFinishedChildTaskExecutionsAndReturn: (where: FinishedChildTaskExecutionStorageWhere, limit?: number) => Array<FinishedChildTaskExecutionStorageValue> | Promise<Array<FinishedChildTaskExecutionStorageValue>>
}
```

## Key Requirements

**Transaction Support**:

- Must support parallel transactions (multiple simultaneous transactions)
- All operations must be atomic within a transaction
- If parallel transactions aren't possible, use sequential execution with mutex

**Ordering Requirements**:

- All operations should be ordered by `updatedAt` ascending
- Ensures consistent task processing across executor instances

**Data Consistency**:

- All operations must be atomic
- No partial updates allowed
- Race condition handling through proper locking

## Drizzle ORM Implementation Pattern

The `durable-execution-storage-drizzle` package provides the canonical implementation pattern:

### Schema Design

**Task Executions Table**:

```typescript
// Identity and hierarchy
id: text('id').primaryKey()
taskId: text('task_id').notNull()
executionId: text('execution_id').notNull().unique()
rootTaskId: text('root_task_id').notNull()
parentTaskId: text('parent_task_id')
parentExecutionId: text('parent_execution_id')

// State management
status: text('status').notNull()
retryAttempts: integer('retry_attempts').notNull()
error: text('error') // JSON serialized error

// Timing control
startAt: integer('start_at', { mode: 'timestamp_ms' }).notNull()
expiresAt: integer('expires_at', { mode: 'timestamp_ms' })
closingExpiresAt: integer('closing_expires_at', { mode: 'timestamp_ms' })

// Task data (JSON serialized)
input: text('input')
runOutput: text('run_output')
output: text('output')

// Child task coordination
childTaskProcessingOrder: text('child_task_processing_order') // JSON array
finishedChildTaskExecutionIds: text('finished_child_task_execution_ids') // JSON array

// Metadata
createdAt: integer('created_at', { mode: 'timestamp_ms' }).notNull()
updatedAt: integer('updated_at', { mode: 'timestamp_ms' }).notNull()
```

**Finished Child Task Executions Table**:

```typescript
// Links to parent task
parentTaskId: text('parent_task_id').notNull()
parentExecutionId: text('parent_execution_id').notNull()

// Child execution data
childExecutionId: text('child_execution_id').notNull()
childTaskId: text('child_task_id').notNull()
processingOrder: integer('processing_order').notNull()
output: text('output') // Serialized child output
error: text('error') // Serialized child error

// Metadata
createdAt: integer('created_at', { mode: 'timestamp_ms' }).notNull()
```

### Database-Specific Implementations

**PostgreSQL** ([durable-execution-storage-drizzle/src/pg.ts](mdc:durable-execution-storage-drizzle/src/pg.ts)):

```typescript
export function createPgStorage<TQueryResult, TFullSchema, TSchema>(
  db: PgDatabase<TQueryResult, TFullSchema, TSchema>,
  taskExecutionsTable: TaskExecutionsPgTable,
  finishedChildTaskExecutionsTable: FinishedChildTaskExecutionsPgTable,
): Storage
```

- Uses `FOR UPDATE SKIP LOCKED` for atomic task claiming
- Native transaction support with row-level locking
- Handles concurrent executor instances efficiently

**MySQL** ([durable-execution-storage-drizzle/src/mysql.ts](mdc:durable-execution-storage-drizzle/src/mysql.ts)):

```typescript
export function createMySqlStorage<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>(
  db: MySqlDatabase<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>,
  taskExecutionsTable: TaskExecutionsMySqlTable,
  finishedChildTaskExecutionsTable: FinishedChildTaskExecutionsMySqlTable,
  getAffectedRowsCount: (result: MySqlQueryResultKind<TQueryResult, never>) => number,
): Storage
```

- Similar to PostgreSQL but requires `getAffectedRowsCount` callback
- Uses MySQL-specific locking mechanisms
- Proper isolation levels for consistency

**SQLite** ([durable-execution-storage-drizzle/src/sqlite.ts](mdc:durable-execution-storage-drizzle/src/sqlite.ts)):

```typescript
export function createSQLiteStorage<TRunResult, TFullSchema, TSchema>(
  db: BaseSQLiteDatabase<'async', TRunResult, TFullSchema, TSchema>,
  taskExecutionsTable: TaskExecutionsSQLiteTable,
  finishedChildTaskExecutionsTable: FinishedChildTaskExecutionsSQLiteTable,
): Storage
```

- Uses mutex-based serialization (SQLite doesn't support concurrent writes)
- All operations wrapped in exclusive locks
- Single-writer, multiple-reader pattern

## Common Utilities

**Data Transformation** ([durable-execution-storage-drizzle/src/common.ts](mdc:durable-execution-storage-drizzle/src/common.ts)):

- Conversion between storage rows and TaskExecution objects
- JSON serialization/deserialization for complex fields
- Error handling and type safety utilities

## Implementation Guidelines

**Factory Pattern**:

```typescript
// Create tables (can customize names)
const taskExecutionsTable = createTaskExecutionsXxxTable('custom_name')
const finishedChildTable = createFinishedChildTaskExecutionsXxxTable('custom_name')

// Create storage instance
const storage = createXxxStorage(db, taskExecutionsTable, finishedChildTable)
```

**Transaction Patterns**:

```typescript
class DatabaseStorage implements Storage {
  async withTransaction<T>(fn: (tx: StorageTx) => Promise<T>): Promise<T> {
    return this.db.transaction(async (tx) => {
      const storageTx = new DatabaseStorageTx(tx, this.tables)
      return fn(storageTx)
    })
  }
}
```

**Locking Strategies**:

- **PostgreSQL/MySQL**: Use `FOR UPDATE SKIP LOCKED` for task claiming
- **SQLite**: Use mutex to serialize all write operations
- **Generic**: Implement retry logic with exponential backoff

## Testing Storage Implementations

Use `durable-execution-storage-test-utils` for comprehensive validation:

```typescript
import { runStorageTest } from 'durable-execution-storage-test-utils'

describe('MyStorage', () => {
  it('should pass all storage tests', async () => {
    const storage = createMyStorage(/* ... */)
    await runStorageTest(storage)
  })
})
```

The test suite validates:

- Basic CRUD operations
- Transaction isolation
- Concurrent access patterns
- Parent-child task relationships
- Error handling and recovery
- Performance characteristics

## Error Handling

**Storage-Level Errors**:

- Database connection failures
- Transaction conflicts and deadlocks
- Constraint violations
- Timeout handling

**Retry Logic**:

- Implement exponential backoff for transient failures
- Distinguish between retryable and non-retryable errors
- Proper error propagation to executor layer

## Performance Considerations

**Indexing Strategy**:

- Primary key on `id`
- Unique index on `executionId`
- Composite indexes on common query patterns
- Optimize for task claiming queries

**Connection Pooling**:

- Use appropriate connection pool sizes
- Configure timeouts and retry logic
- Monitor connection health

**Query Optimization**:

- Use prepared statements where possible
- Batch operations when beneficial
- Avoid N+1 query patterns

Following these patterns ensures storage implementations are robust, performant, and fully compatible with the durable execution engine's requirements.
